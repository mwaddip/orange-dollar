import { opnet, OPNetUnit, Assert, Blockchain, OP20 } from '@btc-vision/unit-test-framework';
import { BinaryWriter, BinaryReader } from '@btc-vision/transaction';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Path to the compiled ORC.wasm bytecode.
 */
const WASM_PATH = path.resolve(__dirname, '../build/ORC.wasm');

/**
 * ORC-specific selectors (generated by opnet-transform from @method decorators).
 * mint(address,uint256) = 0x3950e061
 * burn(address,uint256) = 0xc5b162e8
 * Individual view selectors from OP20:
 * name()       = 0x1581f81c
 * symbol()     = 0x25967ca5
 * decimals()   = 0xbb844440
 */
const MINT_SELECTOR = 0x3950e061;
const BURN_SELECTOR = 0xc5b162e8;
const NAME_SELECTOR = 0x1581f81c;
const SYMBOL_SELECTOR = 0x25967ca5;
const DECIMALS_SELECTOR = 0xbb844440;

/**
 * A thin wrapper around the OP20 ContractRuntime that:
 * - points to our ORC.wasm
 * - encodes the deployment calldata (the ODReserve address)
 * - exposes custom mint/burn helpers using the ORC-specific selectors
 */
class ORCContract extends OP20 {
    /** The reserve address baked into deployment calldata */
    public readonly reserveAddress: import('@btc-vision/transaction').Address;

    constructor(
        address: import('@btc-vision/transaction').Address,
        deployer: import('@btc-vision/transaction').Address,
        reserveAddress: import('@btc-vision/transaction').Address,
    ) {
        // Encode deployment calldata: [reserveAddress (32 bytes)]
        const deploymentCalldata = new BinaryWriter();
        deploymentCalldata.writeAddress(reserveAddress);

        super({
            file: WASM_PATH,
            address,
            deployer,
            decimals: 8,
            deploymentCalldata: deploymentCalldata.getBuffer(),
        });

        this.reserveAddress = reserveAddress;
    }

    /**
     * Calls the name() view method, returns the token name string.
     */
    async tokenName(): Promise<string> {
        const calldata = new BinaryWriter();
        calldata.writeSelector(NAME_SELECTOR);
        const result = await this.executeThrowOnError({
            calldata: calldata.getBuffer(),
            saveStates: false,
        });
        const reader = new BinaryReader(result.response);
        return reader.readStringWithLength();
    }

    /**
     * Calls the symbol() view method, returns the token symbol string.
     */
    async tokenSymbol(): Promise<string> {
        const calldata = new BinaryWriter();
        calldata.writeSelector(SYMBOL_SELECTOR);
        const result = await this.executeThrowOnError({
            calldata: calldata.getBuffer(),
            saveStates: false,
        });
        const reader = new BinaryReader(result.response);
        return reader.readStringWithLength();
    }

    /**
     * Calls the decimals() view method, returns the token decimals as number.
     */
    async tokenDecimals(): Promise<number> {
        const calldata = new BinaryWriter();
        calldata.writeSelector(DECIMALS_SELECTOR);
        const result = await this.executeThrowOnError({
            calldata: calldata.getBuffer(),
            saveStates: false,
        });
        const reader = new BinaryReader(result.response);
        return reader.readU8();
    }

    /**
     * Calls mint(address,uint256) as a given sender.
     * Returns the raw CallResponse (caller can check for error/status).
     */
    async orcMint(
        caller: import('@btc-vision/transaction').Address,
        to: import('@btc-vision/transaction').Address,
        amount: bigint,
    ) {
        const calldata = new BinaryWriter();
        calldata.writeSelector(MINT_SELECTOR);
        calldata.writeAddress(to);
        calldata.writeU256(amount);

        return this.execute({
            calldata: calldata.getBuffer(),
            sender: caller,
            txOrigin: caller,
        });
    }

    /**
     * Calls burn(address,uint256) as a given sender.
     * Returns the raw CallResponse.
     */
    async orcBurn(
        caller: import('@btc-vision/transaction').Address,
        from: import('@btc-vision/transaction').Address,
        amount: bigint,
    ) {
        const calldata = new BinaryWriter();
        calldata.writeSelector(BURN_SELECTOR);
        calldata.writeAddress(from);
        calldata.writeU256(amount);

        return this.execute({
            calldata: calldata.getBuffer(),
            sender: caller,
            txOrigin: caller,
        });
    }
}

await opnet('ORC Token Contract', async (vm: OPNetUnit) => {
    let orc: ORCContract;
    let deployer: import('@btc-vision/transaction').Address;
    let reserveAddress: import('@btc-vision/transaction').Address;
    let userAddress: import('@btc-vision/transaction').Address;
    let attackerAddress: import('@btc-vision/transaction').Address;

    vm.beforeEach(async () => {
        Blockchain.clearContracts();
        await Blockchain.init();

        deployer = Blockchain.generateRandomAddress();
        reserveAddress = Blockchain.generateRandomAddress();
        userAddress = Blockchain.generateRandomAddress();
        attackerAddress = Blockchain.generateRandomAddress();

        const contractAddress = Blockchain.generateRandomAddress();

        orc = new ORCContract(contractAddress, deployer, reserveAddress);
        Blockchain.register(orc);
        await orc.init();
    });

    vm.afterEach(() => {
        orc.dispose();
        Blockchain.clearContracts();
    });

    // ─── Metadata Tests ───────────────────────────────────────────────────────

    await vm.it('should have correct name "Orange Reserve Coin"', async () => {
        const name = await orc.tokenName();
        Assert.equal(name, 'Orange Reserve Coin', 'Token name mismatch');
    });

    await vm.it('should have correct symbol "ORC"', async () => {
        const symbol = await orc.tokenSymbol();
        Assert.equal(symbol, 'ORC', 'Token symbol mismatch');
    });

    await vm.it('should have correct decimals (8)', async () => {
        const decimals = await orc.tokenDecimals();
        Assert.equal(decimals, 8, 'Token decimals mismatch');
    });

    // ─── Mint Tests ───────────────────────────────────────────────────────────

    await vm.it('ODReserve can mint tokens and balance increases', async () => {
        const mintAmount = 1_000_000_00n; // 1 ORC in 8-decimal units (100_000_000 = 1e8)

        const response = await orc.orcMint(reserveAddress, userAddress, mintAmount);
        Assert.equal(
            response.error,
            undefined,
            `Mint reverted unexpectedly: ${response.error?.message}`,
        );

        const balance = await orc.balanceOf(userAddress);
        Assert.equal(balance, mintAmount, 'Balance should equal minted amount');
    });

    await vm.it('Non-reserve address calling mint reverts', async () => {
        const mintAmount = 1_000_000_00n;

        const response = await orc.orcMint(attackerAddress, userAddress, mintAmount);
        Assert.notEqual(response.status, 0, 'Expected revert but got success');

        // Balance should remain zero
        const balance = await orc.balanceOf(userAddress);
        Assert.equal(balance, 0n, 'Balance should remain zero after failed mint');
    });

    await vm.it('Deployer (non-reserve) calling mint reverts', async () => {
        const mintAmount = 1_000_000_00n;

        const response = await orc.orcMint(deployer, userAddress, mintAmount);
        Assert.notEqual(response.status, 0, 'Expected revert but got success');
    });

    // ─── Burn Tests ───────────────────────────────────────────────────────────

    await vm.it('ODReserve can burn tokens and balance decreases', async () => {
        const mintAmount = 1_000_000_00n;
        const burnAmount = 50_000_00n;

        // First mint some tokens
        const mintResponse = await orc.orcMint(reserveAddress, userAddress, mintAmount);
        Assert.equal(mintResponse.error, undefined, `Mint failed: ${mintResponse.error?.message}`);

        // Now burn some
        const burnResponse = await orc.orcBurn(reserveAddress, userAddress, burnAmount);
        Assert.equal(
            burnResponse.error,
            undefined,
            `Burn reverted unexpectedly: ${burnResponse.error?.message}`,
        );

        const balance = await orc.balanceOf(userAddress);
        Assert.equal(balance, mintAmount - burnAmount, 'Balance should decrease by burned amount');
    });

    await vm.it('Non-reserve address calling burn reverts', async () => {
        const mintAmount = 1_000_000_00n;

        // Mint tokens first via the reserve
        await orc.orcMint(reserveAddress, userAddress, mintAmount);

        // Attacker tries to burn
        const burnResponse = await orc.orcBurn(attackerAddress, userAddress, mintAmount);
        Assert.notEqual(burnResponse.status, 0, 'Expected burn to revert for non-reserve caller');

        // Balance should be unchanged
        const balance = await orc.balanceOf(userAddress);
        Assert.equal(balance, mintAmount, 'Balance should be unchanged after failed burn');
    });

    await vm.it('Deployer (non-reserve) calling burn reverts', async () => {
        const mintAmount = 1_000_000_00n;

        await orc.orcMint(reserveAddress, userAddress, mintAmount);

        const burnResponse = await orc.orcBurn(deployer, userAddress, mintAmount);
        Assert.notEqual(burnResponse.status, 0, 'Expected burn to revert for deployer');
    });
});
